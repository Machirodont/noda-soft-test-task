package main

import (
	"context"
	"fmt"
	"main/worker"
	"os"
	"os/signal"
	"runtime"
	"syscall"
)

// Приложение эмулирует получение и обработку неких тасков. Пытается и получать, и обрабатывать в многопоточном режиме.
// После обработки тасков в течении 3 секунд приложение должно выводить накопленные к этому моменту успешные таски и отдельно ошибки обработки тасков.

// ЗАДАНИЕ: сделать из плохого кода хороший и рабочий - as best as you can.
// Важно сохранить логику появления ошибочных тасков.
// Важно оставить асинхронные генерацию и обработку тасков.
// Сделать правильную мультипоточность обработки заданий.
// Обновленный код отправить через pull-request в github
// Как видите, никаких привязок к внешним сервисам нет - полный карт-бланш на модификацию кода.

func main() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// Создание и запуск воркеров
	w := worker.NewWorker(ctx)
	w.Start(runtime.NumCPU())

	// Ожидание завершения работы
	c := make(chan os.Signal, 1)
	signal.Notify(c, os.Interrupt, syscall.SIGTERM)
	<-c

	cancel()
	w.Wait()

	fmt.Println(" Done")
}
