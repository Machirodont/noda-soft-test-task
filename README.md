# Решение публичного тестового задания [NodaSoft](https://github.com/NodaSoft/hr/blob/main/golang/main.go)

Задание оказалось достаточно интересным. Открывает простор для воображения

В тестовом задании функция main представляет собой переусложненный код с неочевидными названиями переменных.
Давайте исправим это. 

Начнем с разделения на пакеты

## Разделение по пакетам 
Я выделил 2 пакета: 
* domain
* services

### Пакет Domain
В данном пакете находятся сущности, специфичные для нашей предметной области.
В данном задании это структура Task и методы работы с состоянием этой сущности

### Пакет services
Данный пакет состоит из следующих сущностей

* orchestrator
* producer
* processor
* presenter

`services.Orchestrator` - отвечает за создание, настройку и управление циклом жизни всех остальных сервисов этого пакета.

`services.producer` - отвечает за генерацию новых тасков

`services.processor` - отвечает за обработку новых тасков, передавая обработанные в каналы успешных и ошибочных тасков

`services.presenter` - отвечает за вывод обработанных тасков на экран. 
Т.к. вывод ошибочных и успешных тасков может быть разный, мы можем разделить `presenter` на две сущности. 
На текущий момент нам хватит и одной.

`Orchestrator` - единственная сущность данного пакета, доступная снаружи. 
Вся асинхронная логика скрыта на уровне пакета и для вызывающего кода все выглядит как обычный синхронный вызов 

При этом мы можем управлять работой оркестратора при помощи переданного контекста, если нам это необходимо, 
используя вызов конструктора `services.NewOrchestratorWithContext`. 

Если нам не нужен контекст, то мы можем использовать просто вызывая конструктор `services.NewOrchestrator`  
## Как этим пользоваться

Пример использования в файле `main.go`
